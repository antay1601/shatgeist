# Как работает ChatGeist

Этот документ описывает архитектуру бота, основанную на **SQL-агенте** с использованием большой языковой модели (LLM). Бот не ищет "похожие" сообщения, а **понимает** запрос пользователя, самостоятельно пишет SQL-код для извлечения данных из истории чата и генерирует на их основе осмысленный ответ.

---

## Часть 1: Создание структурированной базы данных (`import_to_db.py`)

Цель этого этапа — преобразовать сырую историю чата из `chat_history.json` в детализированную, структурированную базу данных SQLite (`qa.db`), пригодную для сложных аналитических запросов.

### Процесс импорта

1.  **Создание таблицы:** Скрипт создает в `qa.db` таблицу `messages` с богатой структурой, включающей множество полей для каждого сообщения:
    *   `message_id`: Уникальный ID сообщения.
    *   `thread_id`: ID "треда" обсуждения (ID первого сообщения в ветке или ID самого сообщения).
    *   `author_id`, `author_name`: Информация об авторе.
    *   `message_text`, `text_length`: Текст сообщения и его длина.
    *   `timestamp`: Дата и время.
    *   `reply_to_message_id`: ID сообщения, на которое был дан ответ.
    *   `has_media`, `has_links`: Флаги, указывающие на наличие медиавложений или ссылок.

2.  **Парсинг и наполнение:** Скрипт проходит по каждому сообщению в `chat_history.json`, извлекает из него все вышеуказанные данные и аккуратно складывает в таблицу `messages` в базе данных `qa.db`.

В результате мы получаем не просто хранилище текстов, а полноценную реляционную базу данных, готовую к сложным SQL-запросам.

---

## Часть 2: Обработка запроса с помощью SQL-агента (`main.py`)

Это ядро системы. Здесь используется **агент** на базе фреймворка `LangChain` и LLM `Claude 3.5 Sonnet`. Агент — это программа, которая может рассуждать, планировать свои действия и использовать инструменты для ответа на вопрос пользователя.

### Управление поведением агента: Системный промпт (`CUSTOM_PROMPT_TEMPLATE`)

Поведение агента определяется не жестким кодом, а **системным промптом** — это набор инструкций, который служит для LLM своего рода "конституцией". Он определяет роль, ограничения и формат вывода для модели.

Ключевые инструкции в `CUSTOM_PROMPT_TEMPLATE`:

1.  **Определение роли:** `Ты — агент, созданный для взаимодействия с SQL базой данных... Твоя задача - отвечать на вопросы пользователя на РУССКОМ ЯЗЫКЕ.` Это задает основной контекст: модель знает, что она — русскоязычный SQL-аналитик.

2.  **Приоритет источника данных:** `Твоя основная функция — запрашивать базу данных... Не придумывай ответ на основе своих общих знаний.` Это критически важное правило для борьбы с "галлюцинациями" LLM. Агент обязан основывать свои ответы только на данных из чата.

3.  **Обработка пустых результатов:** `Если после выполнения SQL-запроса ты получаешь пустой результат, твой финальный ответ должен быть: "К сожалению, в истории чата не нашлось информации..."` Это правило обеспечивает предсказуемое и вежливое поведение в случае, если релевантной информации нет.

4.  **Строгое форматирование ответа:** `Твой финальный ответ должен состоять из двух частей: 1. Сводка... 2. Источники...` Это заставляет агента предоставлять не просто "поток сознания", а структурированный, удобный для пользователя результат, который всегда содержит как краткий вывод, так и доказательства в виде исходных сообщений.

### Инструментарий агента

Чтобы агент мог взаимодействовать с базой данных, ему предоставляется набор "инструментов". В данном случае, это стандартный набор от `LangChain` для работы с SQL, ключевым из которых является `sql_db_query`.

**Инструмент `sql_db_query`**

*   **Назначение:** Это основной и единственный инструмент, который агент использует для **извлечения данных**. Он представляет собой функцию, которая принимает на вход строку с SQL-запросом, выполняет этот запрос к базе данных `qa.db` и возвращает результат.
*   **Как это работает:** Когда в цикле "Мысль-Действие" агент решает, что ему нужна информация, он формулирует SQL-запрос (например, `SELECT * FROM messages LIMIT 5;`) и передает его в `sql_db_query`. Инструмент выполняет код в SQLite и возвращает полученные строки данных обратно агенту в качестве "Наблюдения" (Observation).
*   **Роль в архитектуре:** Этот инструмент — это "руки" агента, его способ "потрогать" данные. Без него все рассуждения агента оставались бы чисто теоретическими. Именно `sql_db_query` связывает логический мир LLM с реальными данными в базе.

Помимо него, агент неявно использует и другие инструменты из того же набора, например, `sql_db_schema` для получения информации о структуре таблиц и их колонках, чтобы писать корректные запросы.

### Цикл "Мысль-Действие" (ReAct)

Агент не просто генерирует SQL-запрос. Он следует циклическому процессу рассуждения и действия, который выглядит так:

1.  **Question (Вопрос):** Агент получает исходный запрос от пользователя (например, "Кто чаще всего писал про визы?").

2.  **Thought (Мысль):** Агент рассуждает на русском языке о том, как ответить на вопрос. *Пример мысли: "Мне нужно найти сообщения, связанные с визами, сгруппировать их по авторам и посчитать количество. Затем я выведу топ-N авторов."*

3.  **Action (Действие):** Агент решает, какой инструмент использовать. В данном случае он выбирает `sql_db_query`.

4.  **Action Input (Входные данные для действия):** Агент **самостоятельно пишет SQL-код**, который реализует его "мысль". *Пример SQL: `SELECT author_name, COUNT(message_id) FROM messages WHERE message_text LIKE '%виз%' GROUP BY author_name ORDER BY COUNT(message_id) DESC LIMIT 3;`*

5.  **Observation (Наблюдение):** SQL-запрос выполняется, и результат (например, таблица с именами и количеством сообщений) передается обратно агенту.

6.  **Thought и Final Answer (Финальная мысль и ответ):** Агент смотрит на полученные данные. Он думает: *"Теперь у меня есть данные. Я могу сформулировать финальный ответ на русском языке, следуя правилу о 'Сводке' и 'Источниках'."* Затем он генерирует итоговый ответ для пользователя.

Этот цикл позволяет агенту действовать автономно, прозрачно (его "мысли" можно логировать) и эффективно, превращая запрос на естественном языке в точный аналитический ответ, основанный на данных.
