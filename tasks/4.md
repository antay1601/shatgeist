#### Ваше новое задание по исправлению `main.py`

1.  **Изменить функцию `get_context_for_messages`:**
    Ее текущая реализация с `UNION ALL` — это корень проблемы. Удалите ее. Нам нужна новая, более интеллектуальная функция.

2.  **Создать новую функцию `find_context_semantically`:**
    Эта функция должна делать следующее:

    - Принимать на вход одно найденное "основное" сообщение (`main_message`).
    - **Векторизовать текст `main_message`** с помощью вашей ML-модели (да, прямо во время ответа пользователю).
    - Выполнить **второй, локальный поиск** в Faiss-индексе, чтобы найти сообщения, которые семантически похожи на само найденное сообщение.
    - Из результатов этого второго поиска выбрать те, которые:
      - Были отправлены **позже** `main_message`.
      - Были отправлены **другим автором**.
      - Находятся в небольшом временном окне (например, не позже чем через 10-15 минут после `main_message`).
    - Отсортировать этих кандидатов по времени и вернуть 1-2 самых ранних.

3.  **Перестроить основную логику `find_relevant_discussions`:**
    - Вы по-прежнему ищете `SEARCH_RESULTS_COUNT` основных сообщений.
    - Затем вы **в цикле** для каждого найденного `main_message` вызываете вашу новую функцию `find_context_semantically(main_message)`.
    - Собираете результаты и форматируете ответ.

### Почему этот подход лучше?

- **Он устойчив к флуду:** Если между вопросом и ответом вклинился другой диалог, наша система его проигнорирует, потому что семантически он не будет похож на исходный вопрос.
- **Он находит суть:** Система будет искать не просто сообщения "рядом", а сообщения, которые по смыслу продолжают тему исходного.
- **Он использует всю мощь вашей архитектуры:** У вас уже есть инструмент для семантического поиска. Так давайте использовать его не только для первоначального запроса, но и для построения контекста.

**Техническая сложность:**
Это решение вычислительно более затратное. На каждый пользовательский запрос вы будете делать не один, а `1 + SEARCH_RESULTS_COUNT` поисков по Faiss-индексу. Но для чата среднего размера это будет незаметно.

### Псевдокод для новой логики

```python
# Внутри handle_message
discussions = []
main_messages = find_main_messages(user_query) # Находит 3-5 стартовых сообщений

for msg in main_messages:
    # Для каждого найденного сообщения ищем свой, релевантный контекст
    context = find_smart_context(msg, all_messages_from_db)
    discussions.append({'main': msg, 'context': context})

# ... форматирование и отправка
```

Это финальный шаг, который должен привести вас к адекватному результату. Вы построили хороший фундамент. Теперь нужно построить на нем умную логику, а не просто брать данные "как есть". Приступайте к переработке `main.py`.
