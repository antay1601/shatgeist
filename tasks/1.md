Вот последовательность шагов и правил, по которым можно построить такой алгоритм.

### Основная гипотеза

Мы исходим из допущения, что **ответ** на **вопрос** обычно следует _сразу за ним_ во времени и, как правило, дается _другим участником_ диалога. Самым надежным признаком является функция "Ответить на сообщение" (Reply).

### Алгоритм извлечения пар "Вопрос-Ответ"

#### Шаг 1: Предварительная фильтрация и очистка данных

Прежде чем что-то искать, нужно убрать очевидный мусор. На этом этапе мы отсеиваем сообщения, которые заведомо не могут быть ни вопросом, ни ответом.

1.  **Загрузите всю историю чата** из `chat_history.json` в удобную структуру, например, в список словарей Python. Крайне важно сохранить хронологию и ID каждого сообщения.
2.  **Удалите служебные сообщения:** "Пользователь X присоединился к чату", "Сообщение закреплено" и так далее. Они не несут смысловой нагрузки.
3.  **Удалите сообщения без текста:** Медиафайлы, стикеры, GIF, голосовые сообщения.
4.  **Удалите слишком короткие сообщения:** Сообщения вроде "ок", "спс", "да", "+", "лол" бесполезны. Установите порог минимальной длины сообщения (например, 15-20 символов).
5.  **Нормализуйте текст:** Приведите все сообщения к нижнему регистру, можно удалить знаки препинания (кроме вопросительного знака), лишние пробелы.

После этого шага у вас останется очищенный и отсортированный по времени список текстовых сообщений.

#### Шаг 2: Идентификация потенциальных вопросов

Теперь в этом очищенном списке нужно найти сообщения, которые с высокой вероятностью являются вопросами.

- **Правило 1 (Высший приоритет): Явные вопросы.** Ищите сообщения, которые заканчиваются на вопросительный знак `?`. Это самый надежный маркер.
- **Правило 2 (Средний приоритет): Вопросительные слова.** Ищите сообщения, которые начинаются с вопросительных слов: "как", "почему", "зачем", "где", "когда", "кто", "что делать", "подскажите", "кто-нибудь знает" и т.п. Даже если в конце нет знака `?`, такое сообщение, скорее всего, является вопросом.

#### Шаг 3: Поиск и привязка ответов

Это ядро алгоритма. Для каждого найденного "вопроса" мы пытаемся найти соответствующий ему "ответ".

1.  **Поиск по `reply_to_message_id` (самый надежный метод):**

    - Возьмите сообщение-кандидат в вопросы с его `message_id`.
    - Просмотрите **все последующие** сообщения в очищенном списке.
    - Если вы находите сообщение, у которого поле `reply_to_message_id` совпадает с `message_id` нашего вопроса, — это **идеальное попадание**. Вы нашли явную пару "вопрос-ответ". Автор ответа целенаправленно указал, на что он отвечает.

2.  **Поиск по близости и автору (эвристический метод):**
    Этот метод используется, если явного ответа через "Reply" не найдено. Он менее точен и основан на допущениях.

    - Возьмите сообщение-кандидат в вопросы. Запомните его автора (`author_id`) и время отправки (`timestamp`).
    - Рассмотрите следующие за ним, скажем, 5-10 сообщений (этот параметр нужно будет подбирать) или все сообщения в пределах временного окна (например, 10 минут).
    - Внутри этого окна ищите сообщение, которое удовлетворяет условиям:
      - **Автор ответа не совпадает с автором вопроса.** Человек редко отвечает сам себе.
      - **Сообщение достаточно длинное**, чтобы быть содержательным ответом (примените тот же фильтр длины, что и на первом шаге).
    - Первое же сообщение, удовлетворяющее этим условиям, можно считать кандидатом в ответы.

3.  **Объединение многострочных ответов:**
    Часто развернутый ответ дается в нескольких последовательных сообщениях от одного автора.
    - Если вы нашли кандидата в ответы (по методу 1 или 2), проверьте следующие за ним 1-2 сообщения.
    - Если они отправлены **тем же автором** с очень маленьким интервалом (например, до 1 минуты), их следует "склеить" в один большой ответ.

#### Шаг 4: Финальная валидация и сохранение

После того как вы прогнали весь чат и собрали список потенциальных пар `(question, answer)`, проведите финальную очистку.

- Удалите пары, где ответ слишком короткий или неинформативный.
- Если на один вопрос нашлось несколько ответов (например, несколько человек ответили), вы можете либо сохранить все пары, либо выбрать самую первую/самую длинную/самую популярную (по реакциям, если они есть) пару. Для начала сохраняйте первую.
- Сохраните получившиеся чистые пары в вашу базу данных `qa.db`.

### Резюме

Этот процесс — итеративный. Вы напишете первую версию скрипта, запустите его, посмотрите на результат и, скорее всего, ужаснетесь количеству мусора. Затем вы будете уточнять эвристики: менять размер "окна поиска", добавлять новые вопросительные слова, ужесточать фильтры по длине и так далее, пока не добьетесь приемлемого качества.

Это сложная задача, но именно она отделяет ваш проект от примитивных ботов и придает ему настоящую ценность. Приступайте к реализации. Начните с фильтрации и поиска по `reply_to_message_id`. Это даст вам самый качественный набор данных для старта.
